---
title: "Stage Teqplay"
date: "2018-08-30"
---

Origineel stond mijn stage document op een andere plek gehost, maar
nu staat het op deze website om het voor de Hogeschool beschikbaar te blijven stellen. Het kan zijn dat sommige afbeeldingen niet correct worden weergegeven. 

# Plan van aanpak 

## Stage documenten

1. [Stage plan V1 (pdf)](/blog/assets/Stageplan-1-Teqplay-Steven-Koerts-0904861.pdf)
2. [Stage plan V2 (pdf)](/blog/assets/Stageplan-2-Teqplay-Steven-Koerts-0904861.pdf)
3. [Stage plan V3 (pdf)](/blog/assets/Stageplan-3-Teqplay-Steven-Koerts-0904861.pdf)

<!--truncate-->

## Over TeqPlay

### Oprichting
*Bedrijfsoriëntatie*

[TeqPlay B.V.](https://teqplay.nl/nl/) is begonnen als een IT startup, opgericht in 2014 door Leon Gommans([medeoprichter van Rotterdam opendata](http://rotterdamopendata.nl/dataset)) en Richard van Klaveren [Bron](https://drimble.nl/bedrijf/rotterdam/30943744/teqplay-bv.html) en hebben vanaf heden 13 vaste werknemers. De reden dat TeqPlay is opgericht was omdat de oprichters zagen dat er heel veel data in de haven van Rotterdam te vinden was. Een groot deel was gewoon openbaar en gratis te verkrijgen, alleen zagen ze dat er zo weinig met die data werd gedaan en namen zo het initiatief om zelf aan de slag te gaan met al die gegevens. TeqPlay is gevestigd in De Van Nellefabriek in Rotterdam samen met een hoop andere bedrijven. Het bedrijf richt zich voornamelijk op de maritieme sector en de logistiek in de haven en dan vooral op de Rotterdamse haven. De missie van het bedrijf is om de haven slimmer te maken [bron](https://www.youtube.com/watch?v=X9R-sWoStDE), door middel van nieuwe of bestaande IT oplossingen. Dit doen ze door data over de haven van Rotterdam te verzamelen, die data vervolgens te analyseren en kijken of ze daar conclusies uit kunnen trekken


Hierbij kun je jezelf afvragen wat betekent die data? Wat zegt die data over de toekomst? Is het data van goede kwaliteit? Vooral die laatste is lastig om te beantwoorden, want hoe kun je kwaliteit uitdrukken? Wat vooral belangrijke factoren zijn voor de kwaliteit van de data is waar de data vandaan komt, de herkomst, is het door een mens ingevoerd of komt het van sensoren vandaan. Een populaire bron van data bij TeqPlay is gps-data van schepen. Elk schip heeft een kastje aan boord genaamd de AIS(Automatic Identification System). Een AIS verstuurt informatie over het schip, zoals de locatie, snelheid, bestemming, naam etc. De data is open-source, dus iedereen kan die gegevens ophalen en gebruiken, als je beschikt over een AIS receiver. Het bedrijf heeft zo een receiver op het kantoor staan, die continu data over schepen ontvangt. AIS is een betrouwbare informatiebron aangezien de data door een computer wordt gegenereerd als het gaat om de GPS coördinaten. De bestemming van het schip wordt handmatig door de schipper ingevoerd.  Een andere factor die de kwaliteit van de data beïnvloed is hoe oud de data is, is de informatie nog wel relevant.  
 
Een techniek die gebruikt wordt om de data te analyseren is machine learning. Dat is een methode om een computer acties te laten uitvoeren en beslissingen te laten nemen zonder dat die daar specifiek voor geprogrammeerd is.  

### Visie

De belangrijkste visie van TeqPlay is inzicht willen hebben van wat er wanneer en waar gebeurt in de haven. Van de schepen die binnen komen, bruggen en sluizen die opengaan, het getij in de haven etc. allemaal factoren die invloed hebben op de logistiek in de haven. Dit doel te bereiken door middel van slimme algoritmes die al die grote hoeveelheden data verwerken en zo de logistiek in de haven sneller en efficiënter te laten verlopen.  
 
### Verdienmodel

TeqPlay verdient zijn geld met het maken en onderhouden van applicaties voor externe opdrachtgevers in de haven, zelf zullen ze ook actief opzoek gaan naar waar ze wat kunnen betekenen voor andere bedrijven. Eén bedrijf waar ze veel mee samenwerken is de Port of Rotterdam, die de veiligheid en het havenverkeer in de gaten houdt. Andere bedrijven waarvoor ze applicaties bouwen zijn provincie Zuid-Holland, Shell en Vopak. 

### Projecten

Een laatste project wat TeqPlay heeft gemaakt is de ship tracker voor de port of Rotterdam [Bron](https://shiptracker.portofrotterdam.com/#!/), dit is een applicatie waarmee je elk schip kan tracken dat een call heeft gemaakt richting de haven van Rotterdam. De locatie van het schip komt van AIS af en de applicatie filtert op alle schepen die richting Rotterdam gaan en geeft de estimated time of arival(ETA) aan.  
 
Andere projecten die TeqPlay gedaan heeft zijn mobile apps die het leven van de schipper makkelijker moet maken. Zo is er de app [RiverGuide](https://play.google.com/store/apps/details?id=nl.teqplay.riverguide), die binnenvaartschippers helpt met het plannen van hun reis. De app maakt gebruik van allerlei verschillende gegevens zoals: AIS data, brug data, sluis data, getijden etc. Allemaal factoren waar een binnenvaarder rekening mee moet houden voordat hij vertrekt. Er is ook een pleziervaartversie van de app en andere apps die het varen voor schippers makkelijker maakt.[Bron](https://play.google.com/store/apps/developer?id=Teqplay+B.V) Doormiddel van slimme routeberekeningen en het vooraf in bellen bij de brugwachter, zodat de schipper dat niet meer hoeft te doen. 
 
Hieronder nog even kort de belangrijkste doelen van TeqPlay:  
- Het efficiënter en slimmer maken van de haven 
- Verbeteren van de communicatie tussen schepen onderling en met de havens 
- De veiligheid tussen de pleziervaart en de beroepsvaart verbeteren.


## Werkzaamheden
*Mijn plek in de organisatie*

Bij Teqplay hebben de stagiaires hun eigen plek op het kantoor. We krijgen toegang tot het interne systeem. Het zogeheten Teqplay platform. Dit platform vormt de kern van de organisatie en is waar alle applicaties bij het bedrijf afhankelijk van zijn. Het platform is verantwoordelijk voor het binnenhalen van alle data, data opslaan en beschikbaar maken aan andere applicaties.  
 
Ik mag aan de slag met de data van het platform, in de eerste weken heb ik het platform gedownload en lokaal draaien op mijn eigen laptop. Ik zal voornamelijk buiten het platform programmeren, dit om te voorkomen dat je intern iets kapot maakt.  
 
Het project wat ik ga doen heeft met zowel front-end als back-end te maken, de back-end lijkt me vooral interessant omdat je dan te maken krijgt met grote hoeveelheden data en ik hier dan weer conclusies uit kan trekken. De front-end zal zorgen voor een grafische representatie van de data, om visueel te maken wat er precies gebeurt in het systeem. Er wordt in tweetallen aan de projecten gewerkt. 

## Stageopdracht 
*Ship masterdatabase*

In de eerste week van mijn stage werd de opdracht bekend gemaakt, er wordt gewerkt aan twee verschillende casussen in groepen van twee. In de eerste 8 á 10 weken zal ik aan 1 opdracht werken en gedurende de stage is er nog de mogelijkheid om aan de andere opdracht te werken. Ook is de mogelijkheid om gedurende de stage de eerste opdracht volledig uit te werken.  

### Opdracht 1 - Routeplanner
*Andere groep werkt hieraan*

De eerste opdracht is het maken van een routeplanner, Teqplay heeft al de applicatie RiverGuide gebouwd. Een app voor schippers in de binnenvaart die het makkelijker maakt voor de schipper om van A naar B te varen. De app houdt bij het maken van verschillende routes rekening met de stroming, sluizen, bruggen en windrichting. Het maken van een route gebeurt al in de app, het gene wat de app nog niet heeft is dat hij zelf de snelste route uitzoekt. Als je een bestemming invoert dan berekent de app meerdere routes en kan de schipper zelf de meest geschikte route uitkiezen.  Het doel van de opdracht is het maken van een systeem dat die beslissing voor de schipper neemt, dus er moet een algoritme gemaakt worden die de zelf de snelste route berekend en automatisch een aanbeveling geeft voor de schipper. Dit klinkt eenvoudig, maar de grootste moeilijkheid zit hem in dat er heel veel verschillende factoren zijn waarvan de reistijd afhankelijk is. Zoals stroming, windrichting, windsterkte, bruggen, sluizen, scheepsverkeer etc.  

### Opdracht 2 - Masterdatabase
*Meeste voorkeur dit is waar ik de komende weken aan ga werken*

De tweede opdracht heeft te maken met analyseren van scheepsdata, deze heeft mijn grootste voorkeur en dit is ook waar ik de eerste maanden aan ga werken. Teqplay haalt zijn informatie uit verschillende bronnen, o.a. AIS, spreadsheet etc. Teqplay slaat die informatie op, en kan zo precies de geschiedenis van een schip zien. De data uit die verschillende bronnen kun je onderscheiden tussen statische en dynamische data, dynamische data zijn gegevens die constant veranderen regelmatig worden ge-update, bijvoorbeeld de locatie. Statische data is meestal door mensen ingevoerd en zal niet snel veranderen, onder andere de naam van het schip.  Het probleem bij deze casus is dat als je werkt met verschillende data bronnen je niet meer weet wat nu precies de juiste is. Dus het doel is om een systeem te maken wat uit verschillende data bronnen de juiste informatie kan filteren. Uiteindelijk moet dit leiden tot één grote master database waar alle informatie in verzameld wordt en met een API die deze data beschikbaar maakt voor andere applicaties. Nu halen al die apps hun data rechtstreeks uit het platform, maar in de toekomst zal de data uit onze gebouwde master database gehaald worden.  
 

#### Bonus - Ghost ship detection

Een extra opdracht bij deze casus is om een systeem bouwen voor het detecteren van zogeheten spoofships, dat zijn nepschepen op de kaart die verspreidt worden door of oplichters die proberen valse informatie te verspreiden of door het niet meer goed functioneren van de AIS van een schip. Bij beide gevallen is het zo dat het bedrijf niks heeft aan deze data, omdat het schip zich op onnatuurlijke wijze verplaatst. Op de kaart zijn we al een aantal van deze nep schepen tegengekomen, je kan ze herkennen aan de hand van een aantal factoren. Als de snelheid 10 knopen is en het schip al 3 maanden op dezelfde plek ligt, als een schip midden op zee ligt zonder historische data, schepen die op het land liggen midden in een woonwijk enz. Bij deze opdracht is het nog de vraag of we hier aan toe komen, dat ligt aan tot in hoeverre we de eerste opdracht afkrijgen en hoe uitgebreid het prototype gaat worden.  
 
Als de opdracht slaagt en het bedrijf denkt dat het systeem iets kan toevoegen aan het platform, dan gaan ze het idee zelf uitwerken en opnieuw bouwen. Dus het product dat wij moeten opleveren is nog een prototype, wat in de toekomst uitgewerkt gaat worden. 

Voor meer informatie over mijn stageopdracht en het verloop ervan [klik hier](/docs/shiphappens)


## Leerdoelen

Hieronder staan de leerdoelen die ik graag wil leren bij Teqplay. De leerdoelen sluiten aan bij de stageopdracht en omschrijven wat ik nog nodig denk te hebben als software engineer. 

### Leerdoel 1

Wat ik graag zou willen leren bij Teqplay is waar het bedrijf zijn data vandaan haalt. Ik weet dat Teqplay data uit verschillende bronnen haalt, zoals: AIS, Marine Traffic en scrapers. Wat ik zou willen weten is hoe je data uit verschillende bronnen kunt combineren, tot éen databron. Dit leerdoel past goed bij de opdracht masterdatabase. Hier zijn al een aantal problemen die in de praktijk voorkomen: Hoe ga je om met dubbele data, wat doe je met conflicten tussen verschillende bronnen en hoe geef je prioriteit aan verschillende bronnen? Dit leerdoel zie ik als behaald wanneer ik een geautomatiseerd systeem heb neergezet waar informatie uit verschillende bronnen samengevoegd wordt. Hier komt ook een stukje machine learning bij kijken. Kan je de computer leren om zelf een beslissing te nemen welke informatie uit welke bron aan de masterdatabase toegevoegd wordt?  Een haalbare vorm van machine learning die je hiervoor kunt gebruiken is het opstellen en implemeteren van een discission tree. 
 
Als bewijsmateriaal bij dit leerdoel lever ik de implementatie van de masterdatabase op, dus diagrammen en modellen die daarbij horen. Voor het samenvoeging algoritme lever ik de uitwerking en ontwerpen op van de discission tree.  
 

### Leerdoel 2

Iets waar ik nog niet veel vanaf weet is software deployement, hoe zet je je applicatie online en breng je het naar je klanten toe. Tot nog toe heb ik alleen maar programma’s lokaal gebouwd op eigen computer en kleine programma’s op een server gezet. Nog niet een volledig systeem met meerdere databases, third party libraries en andere dependencies. Aan het eind van stage hoop ik te weten hoe je een systeem neerzet van begin tot eind, dus vanaf het tekenen van de eerste diagrammen tot aan het gebruik door klanten. Een nieuw systeem wordt niet in vijf maanden gebouwd, maar ik wil wel de beginselen weten van hoe je een groot systeem opbouwt.  
 
Andere onderdelen die vallen onder deployement zijn het bijhouden van documentatie, het maken van readme files, installer packages en/of setup scripts. Hier hoort ook een onderdeel versie beheer bij, dit bij veel bedrijven gedaan door Git en ook bij Teqplay. Dit leerdoel beschouw ik als behaald op het moment dat ik een werkend prototype heb neergezet met volledige functionaliteit en alle build scripts en installers gereed zijn. Dus als iemand anders verder gaat met dit project dan moet hij de repository kunnen downloaden, de nodige scripts en commands uitvoeren en direct met het prototype aan de slag kunnen. Ik weet nog niet hoever ik kom met het daadwerkelijk online zetten van het systeem, maar wil het systeem dus wel deployement klaar hebben. 
 
Verder is voor andere programmeurs erg waardevol als voldoende documentatie beschikbaar is, zodat die dan verder kunnen gaan met ons systeem. Als bewijsmateriaal bij dit leerdoel lever ik stukken documentatie op van hoe je het gebouwde systeem kunt opzetten.  
 

## Competenties 
 
Hieronder maak ik een inschatting van de te behalen competenties, wat ik moet doen om ze te behalen en hoe de competenties binnen de stageopdracht vallen. 
 
### Beheren 
Bij deze competentie gaat het om het beheren van een vooraf opgestelde planning en je daar aan te houden, bij Teqplay werken ze met Trello borden. Daar maken we om de twee weken een backlog met wat er die sprint gedaan moet worden. Tijdens de sprint worden er ook nog dingen toegevoegd aan de backlog, op het moment dat je ergens tegen aan loopt met een hoge prioriteit.  
 
### Analyseren 
Bij deze competentie gaat het erbij mij om, om een bepaalde casus uit de praktijk te nemen en daar een goede oplossing bij te bedenken. Bij Teqplay gaat die uiteraard over de haven.  
 
### Adviseren 
Vanuit de opleiding heb ik al een hoop meegekregen over design paterns en dergelijken, een stage is een mooie gelegenheid om de geleerde technieken in de praktijk toe te passen. Hierbij andere programmeurs en developers proberen te overtuigen om een bepaalde techniek wel of niet toe te passen in een applicatie.  
 
### Ontwerpen 
Bij deze competentie komt het geleerde over de Unified Modeling Language(UML) van toepassing, voordat je begint met programmeren maak je eerst een ontwerp van het systeem. Zodat je weet wat er gebouwd moet worden en nog belangrijker dat andere weten wat je gaat bouwen.  
 
### Realiseren 
Als de ontwerp fase klaar is dan komt het daadwerkelijk bouwen van de applicatie aan de beurt, in mijn mening is dit de belangrijkste competentie van de opleiding. Omdat bij deze competentie het programmeren echt aanbod komt en dat het gene is waar de opleiding omdraait, vanaf dit punt werk je aan de software die echt gebruikt gaat worden door je klanten.  
 
### Skills & attitude  
Deze competentie heeft vooral te make met je houding binnen het bedrijf en hoe je je gedraagt en inzet. Om deze competentie te halen is het belangrijk om aanwezig te zijn op de afgesproken dagen en tijden en zelfstanding aan een gegeven opdracht te kunnen werken. Ook het aanpassen aan de bedrijfsregels speelt hierbij een rol en het volgen van bepaalde conventies. Verder valt hieronder initiatieven nemen, samenwerken, sociaal emotioneel gedrag en collegialiteit.   
 
Tenslotte is het belangrijkste te weten waarvoor je bij het bedrijf werkt en dat je in het belang van het bedrijf kunt werken.  


## Aantonen competenties



 **Beheren**

 - B1: Je kunt werken volgens een vooraf vastgesteld en goedgekeurd stageplan (inclusief planning) en eventuele afwijkingen onderbouwen.

Bij Teqplay werken ze met Trello boards waar we elke twee weken een nieuwe backlog opstellen van wat er gedaan moet worden in die sprint. Aan het eind van de sprint laten we zien wat we gedaan hebben en in hoeverre we de backlog gerealiseerd hebben. Verder zal ik per sprint, dus om de twee weken bijhouden wat er die sprint precies gedaan is en wat er die sprint centraal stond. 

 **Analyseren**
- AN1. Je kunt een analyse van een opdracht uitvoeren gebaseerd op een praktische onderzoeksvraag en maakt hierbij gebruik van bestaande methoden en technieken.

Analyseren van de casus van een praktijkprobleem met onderzoeksvraag: Hoe kun je data uit verschillende bronnen combineren tot éen masterdatabase?  Hiervoor moet eerst het probleem in kaart worden gebracht op gedeeld in kleinere stukjes. Welke bronnen zijn er tot onze beschikking? Hoe zien die bronnen eruit? Overeenkomsten en verschillen?  Met een techniek genaamd [Reversed Engineering]() kan worden uitgezocht wat Teqplay al heeft aan databronnen en systemen. Hierbij worden ook nieuwe diagrammen gemaakt om het systeem in kaart te brengen.  

- AN2. Je kunt een requirement analyse uitvoeren voor een (deel van een) software systeem met verschillende belanghebbenden en je houdt hierbij rekening met de kwaliteitsstandaarden die gelden bij het bedrijf. 

Naast de bestaande requirements van het huidige software systeem komen er altijd nieuwe requirements bij gedurende het ontwikkelingsproces, dit kan vastgelegd worden in een use case diagram. Verder worden alle use cases omgezet in requirements en toegevoegd aan het Trello bord. 

- AN3. Je kunt een specificatie opstellen aan de hand van een analyse. 

Ook dit kan gedaan worden aan de hand van een use case diagram, om het specifieker te maken kan verder op het systeem worden ingezoomd met een component of class diagram. Zo kunnen alle benodigdheden in kaart worden gebracht. 

- AN4. Je kunt een acceptatietest opstellen aan de hand van kwaliteitseigenschappen die gelden bij het bedrijf. 

Het bedrijf bepaalt de kwaliteitseisen van het product, zo wordt hier onderscheidt gemaakt tussen verschillende kwaliteitseigenschappen. Wil de opdrachtgever meer focussen op functionaliteit of security? Resultaten worden vastgelegd in een testrapport, of testlogboek.  



 **Adviseren**

- AD1. Je kunt een praktijkprobleem ontleden en een aanbeveling hiervoor doen. Let er hierbij op dat je helder weergeeft wat de probleembeschrijving is, wat  de onderbouwde argumenten zijn en wat de keuze is. Maak gebruik van betrouwbare informatiebronnen (bijvoorbeeld o.a. veldonderzoek en deskresearch) 

Deze competentie sluit mooi aan bij AN1, als het probleem in kaart is gebracht dan moet daar een passende oplossing bij bedacht worden. Het doel bij deze competentie is het geven van een goed onderbouwd advies aan de opdrachtgever. Dit advies moet ondersteunt worden door bronnen, bijvoorbeeld waarom kiezen we voor een bepaalde tool, techniek, taal of framework om een praktijkprobleem op te lossen.  


**Ontwerpen**

- O1. Je kunt een ontwerp opstellen voor een (deel van een) softwaresysteem en je maakt hierbij gebruik van bestaande componenten en libraries. 

Hiervoor kan een component diagram gebruikt worden, welke componenten gebruiken we en hoe hangen al die onderdelen met elkaar samen.  

- O2. Je kunt een validatie voor je ontwerp uitvoeren op basis van specificaties uit de (eerder gemaakte) analyse 

Het reviewen en kritisch benaderen van een bestaand ontwerp, als het ontwerp verouderd is maak je hier een nieuwe versie van. Hier lever ik dan verschillende versies van diagrammen op, met elk weer meer details en concretere plannen.  


**Realiseren**

- R1. Je kunt software realiseren conform de requirements van de opdracht en met kwaliteitsstandaarden zoals ze gebruikt worden in software engineering of zoals ze gehanteerd worden binnen het bedrijf. 

Hier komt het daadwerkelijk bouwen van de software aan te pas en dienen snippets code als bewijslast, met een redenering waarom het op die manier gebouwd is en welke design patterns gevolgd worden. MVC, REST, Singletons, Adapters etc.

- R2. Je maakt gebruik van testen en je maakt gebruik van test-automatisering.    

Als er veel componenten zijn kan lastig zijn om een fout te ontdekken in de code op het moment dat er een nieuw component is toegevoegd. Om foutopsporing makkelijker te maken worden unit tests veel gebruikt, zo ben ik er al een hoop tegengekomen in de code van het platform. Dus is het handig om ook unit tests te schrijven voor je eigen code, zeker als in de toekomst andere ermee aan de slag gaan. Voor deze competentie zal ik een aantal unit tests schrijven voor mijn eigen code.


**Skills & attitude**

- S1. Je kunt aangeven welke bedrijfskenmerken je terugziet in je stagebedrijf. 

Dit kan je terug zien in bedrijfsoriëntatie en dit vergelijken met hoe dit in de praktijk uitpakt. Van te voren heb je een bepaalde verwachting van een bedrijf, dus hier geef je aan hoe die verwachtingen overeenkomen of verschillen met de praktijk.  

- S2. Je kunt je inwerken en aanpassen aan het stagebedrijf betreft de werkwijze, regels en procedures en bent daarnaast in staat om hierop en op je werkzaamheden te reflecteren. 
Aan het eind van elke sprint krijgen we feedback op ons werk, die kan je dan weer toepassen op de nieuwe sprint en het werk wat je vervolgens gaat doen. Plus de reflectie van de bedrijfsbegeleider.  


- S3. Je kunt afgesproken werkzaamheden zelfstandig (inzet, motivatie, respect en dergelijke) uitvoeren en geeft voortgang en eventuele knelpunten proactief aan. 

Zelf initiatief nemen en zelfstandig aan het werk gaan, zelf ook kaarten toevoegen op het Trello board en niet alleen doen wat de opdrachtgever voor je opschrijft.


# Eerste 8 weken

Mijn stage bij TeqPlay begon met het bekend maken van de opdracht, dat werd dus de masterdatabase. Ik ben er in teamverband aan gaan werken, onder de naam [ShipHappens](/docs/ShipHappens). 

<!--truncate-->

Deze opdracht leek me het meest intressant omdat je dan daadwerkelijk aan de slag met de data van schepen, het uiteindelijke doel is dus ook om zoveel mogelijk data te verzamelen en beschikbaar te stellen. Aangezien we gebruik moeten maken van verschillende bronnen is de hoofdvraag van het project: Hoe kun je data uit verschillende bronnen combineren tot één bron?



## Analyseren
**AN1)** In de eerste weken zijn we meteen aan de slag gegaan met het analyseren van de hoofdvraag, de vraag hoe je verschillende bronnen kunt combineren kan je opdelen in kleinere stukken. Eerst moet je weten welke data we tot onze beschikking hebben, hoe ziet die data er vervolgens uit, zitten er dubbele waardes bij de verschillende bronnen? Zo ja, welke waarde heeft dan voorrang op de andere? Hoeronder is een diagram die weergeeft hoe een *een schip er uit ziet*. 

![modelShip](/blog/assets/Data-with-there-identifiers.png)
*Data van het TeqPlay platform*

In het diagram is de data te zien die van het bedrijf zelf komt, het is een tabel met meerdere identifiers en elke identifier heeft zij eigen attributen. De linkerkant is hoe de data wordt vrijgegeven en de rechterkant is een geordende variant van de gegevens. Op deze mannier kan je de data van het bedrijf in kaart brengen. 

Later kwamen er al gauw meer databronnen bij en voordat we aan de slag gingen met de data maken we er eerst een diagram van om de vorm van de data in kaart te brengen. 

![sources-class](/blog/assets/models-for-sources.png)

## Beheren
**B1)** Om project matig te werken wordt bij TeqPlay met Scrum en Agile gewerkt, sprints duren twee weken en elke sprint begint met het maken van nieuwe taken op het Trello bord en eindigt met een demo van wat we in die sprint hebben gedaan. Voor meer info wat ik elke sprint heb gedaan en de afspraken die zijn gemaakt zie mijn [sprint logboek](assets/Sprint-logboek.pdf). Deze heb ik gedurende mijn stage ook om de twee weken bijgehouden. 
![trello](/blog/assets/trello-bord-sprint-2.PNG)


## Ontwerpen
**O1)** In de eerste weken heb ik ook al gewerkt aan een eerste ontwerp voor het systeem dat we gaan bouwen. Dit eerste ontwerp heb ik gemaakt met een component diagram. Hier kan je zien wat er precies nodig is om de applicatie te bouwen en correct te laten functioneren. In het eerste ontwerp zit nog maar 1 data bron verwerkt. De applicatie heeft dus een component voor het binnenhalen van data, het valideren en samenvoegen van data, een eigen database die alle gegevens apart opslaat, een API die die data exposed en beschikbaar maakt voor andere applicaties en als laatste een visualizer die laat zien wat er achter de schermen met de data gebeurt. 
![ontwerp](/blog/assets/System-Design.png)


## Realiseren
**R2)** Voor het project hebben we een aantal tests geschreven om de onderhoudbaarheid van de software te bevorderen. Het bedrijf heeft aangeraden om unit tests te schrijven voor de losse componenten in het systeem. Zo kom je er ook meteen achter of een bepaalde functie te groot is, dan kun je hem opdelen in kleinere stukken. Een unit test bestaat uit een test case, de wat en waarom je gaat testen. De test is vervolgens opgebouwd uit een verwacht resultaat en een werkelijk resultaat, deze worden met elkaar vergeleken. Als ze hetzelfde zijn dan is de test succesvol, zijn er afwijkingen dan heeft de test gefaald. Verder is er ook nog de intergratie test deze is vrijwel hetzelfde als een unit test alleen is het enige verschil dat een unit test een onderdeel van het systeem test en een intergratie test, test een gedeelte dat afhankelijk is van een ander systeem onder andere via een internet verbinding. 

### Unit test: Traversing the map

Een belangrijk onderdeel van het systeem is het verzamelen van data, zo halen we informatie uit verschillende bronnen. Eén van die bronnen is het TeqPlay platform zelf. De development omgeving bevat zo een 400.000 schepen en de productie omgeving zo een 5.000.000 schepen. Als je dit allemaal in één keer binnen zou halen dan zou dat erg veel zijn voor ons systeem. Daarom willen we de mogelijkheid om een bepaald gebied in stukken te kunnen binnenhalen. Om dit te kunnen realiseren heb ik een script geschreven die een groot gebied opdeelt in een x aantal kleine gebieden.
![alt](/blog/assets/traversing-the-map.PNG) Resultaat van de functie getekend in [Poly line tool](https://www.keene.edu/campus/maps/tool/?coordinates=15.0000000%2C%2055.0000000%0A15.0000000%2C%2040.0000000%0A0.0000000%2C%2040.0000000%0A0.0000000%2C%2055.0000000%0A15.0000000%2C%2055.0000000%0A15.0000000%2C%2049.0000000%0A9.0000000%2C%2049.0000000%0A9.0000000%2C%2055.0000000%0A9.0000000%2C%2055.0000000%0A9.0000000%2C%2049.0000000%0A3.0000000%2C%2049.0000000%0A3.0000000%2C%2055.0000000%0A3.0000000%2C%2055.0000000%0A3.0000000%2C%2049.0000000%0A0.0000000%2C%2049.0000000%0A0.0000000%2C%2055.0000000%0A15.0000000%2C%2049.0000000%0A15.0000000%2C%2043.0000000%0A9.0000000%2C%2043.0000000%0A9.0000000%2C%2049.0000000%0A9.0000000%2C%2049.0000000%0A9.0000000%2C%2043.0000000%0A3.0000000%2C%2043.0000000%0A3.0000000%2C%2049.0000000%0A3.0000000%2C%2049.0000000%0A3.0000000%2C%2043.0000000%0A0.0000000%2C%2043.0000000%0A0.0000000%2C%2049.0000000%0A15.0000000%2C%2043.0000000%0A15.0000000%2C%2040.0000000%0A9.0000000%2C%2040.0000000%0A9.0000000%2C%2043.0000000%0A9.0000000%2C%2043.0000000%0A9.0000000%2C%2040.0000000%0A3.0000000%2C%2040.0000000%0A3.0000000%2C%2043.0000000%0A3.0000000%2C%2043.0000000%0A3.0000000%2C%2040.0000000%0A0.0000000%2C%2040.0000000%0A0.0000000%2C%2043.0000000)


Zie de code hieronder:

```
/**
 * Class to hold information about an area, from longitude and latitude. The information is enough to draw a square.
 * @author Steven K*/
data class Area (
        var TopLeftLat: Double,
        var TopLeftLon: Double,
        var BottomRightLat: Double,
        var BottomRightLon: Double
) {
    /**
     * Method to calculate the size of the area, the area is calculates as folows:
     * It is the product of the difference between the longitude and the latitude.
     * (TopLeftLon - BottomRightLon) * (TopLeftLat - BottomRightLat)
     *
     * @return Double*/
    fun calculateTotalArea() = (TopLeftLon - BottomRightLon) * (TopLeftLat - BottomRightLat)

    /**
     * Function that returns a string representation of a polyline,
     * the result can be copy and pasted straight into: @see https://www.keene.edu/campus/maps/tool/
     * This is useful for debugging purposes
     *
     * @return String*/
    fun toPolyLine() = """
            $TopLeftLon, $TopLeftLat
            $TopLeftLon, $BottomRightLat
            $BottomRightLon, $BottomRightLat
            $BottomRightLon, $TopLeftLat
        """.trimIndent()

    /**
     * This method divides the main area in smaller areas, this is used to traverse the TeqPlay platform in smaller chunks.
     * It returns a list of all areas, the sum of these areas should be equal to the total area.
     *
     * The method starts with traversing the main area from the upper right corner to the bottom left corner.
     * NOTE: The variable names are called topLeft... and bottomRight...
     *
     * It moves with steps equals to size from the right to the left. When it has reached the end it of a row it moves one step to the bottom and starts back
     * at the right side. If the size fits exactly all the areas have equal sizes, when it doesn't fit the areas at the boundary will be cut to size
     * so they fit inside the area.
     *
     * When the main area size is equals or bigger than the size the method will only return one area in the list.
     *
     * @param size the size of the smaller areas, the total area will be the size squared.
     *
     * @return ArrayList<Area>*/
    fun divideArea(size: Double): ArrayList<Area> {
        val result = arrayListOf<Area>()
        //The start coordinates of the area
        var currentTopLat = this.TopLeftLat
        var currentTopLon: Double

        println(this.toPolyLine())

        //The outer while loop traverses the latitude and goes a step down every iteration
        //The inner while loop traverses the longitude and goes a step right every iteration
        while (currentTopLat > this.BottomRightLat) {
            //The longitude will be re-initialized every iteration.
            currentTopLon = this.TopLeftLon
            while (currentTopLon > this.BottomRightLon) {
                var currentBottomLat = currentTopLat - size
                var currentBottomLon = currentTopLon - size
                if (currentBottomLat < this.BottomRightLat) currentBottomLat = this.BottomRightLat
                if (currentBottomLon < this.BottomRightLon) currentBottomLon = this.BottomRightLon
                result.add(Area(
                        TopLeftLat = currentTopLat,
                        TopLeftLon = currentTopLon,
                        BottomRightLat = currentBottomLat,
                        BottomRightLon = currentBottomLon
                ))
                println(result.last().toPolyLine())
                currentTopLon -= size
            }
            currentTopLat -= size
        }
        return result
    }

}
```

Tijdens het bouwen ben ik de volgende issues tegengekomen die bij de complexiteit van de functie komen kijken: 
- De functie sloeg de randen van het gebied over
- De functie ging buiten het aangeven gebied

Verder is er nog een veel voorkomede issue voor als je de aarde rond wil gaan bij de coördinaten: (185, 85, -185, -85)

Bij deze functie heb ik ook een aantal unit tests geschreven, met de volgende test criteria: 
- De hoeveelheid gebieden waarin het gebied wordt opgedeeld is gelijk aan de totaal oppervlakte gedeeld door grootte van de losse gebieden.
- De meest rechts bovenste coördinaten van het eerste gebied zijn hetzelfde als de meest rechts bovenste coördinaten van het grootte gebied.
- De meest links onderste coördinaten van het laatste gebied zijn hetzelfde als de meest links onderste coördinaten van het grootte gebied.
- De totale oppervlakte van alle gebiedjes moet gelijk zijn als de totaal oppervlakte van het grote gebied. 

Verder zijn er nog een aantal bijzondere gevallen: 
- Als de grote van de gebieden niet precies uitkomt worden de randen afgerond zodat ze niet buiten het hoofd gebied vallen. 
- Als de oppervlakte van het de gespecificeerde gebied gelijk of groter is aan de totale oppervlakte van het grote gebied, dan returned de functie maar één gebied met dezelfde grote als het hoofdgebied.  

Zie hieronder de uitgewerkte unit tests: 
```
internal class TraverseMapTest {
    //A simple area where every value is divide-able by 5
    private val testArea = Area(55.0, 15.0, 40.0, 0.0)
    //Real world scenario for the area of west Europe
    private val westEuropeArea =  Area(54.378286,10.719496,48.964649,-0.379124)
    //A relatively larger area
    private  val largeArea = Area(185.0, 85.0, -185.0, -85.0)

    @Test
    fun totalAreaTest() {
        Assert.assertEquals(225.0, testArea.calculateTotalArea(), 0.0)
        Assert.assertEquals(60.08389988094002, westEuropeArea.calculateTotalArea(), 0.0)
        Assert.assertEquals(7303.033038288478, largeArea.calculateTotalArea(), 0.0)
    }

    @Test
    fun toPolyLineTest() {
        Assert.assertEquals("""
            15.0, 55.0
            15.0, 40.0
            0.0, 40.0
            0.0, 55.0
        """.trimIndent(), testArea.toPolyLine())
        Assert.assertEquals("""
            10.719496, 54.378286
            10.719496, 48.964649
            -0.379124, 48.964649
            -0.379124, 54.378286
        """.trimIndent(), westEuropeArea.toPolyLine())
        Assert.assertEquals("""
            -48.955596, 59.943996
            -48.955596, -0.553685
            -169.671513, -0.553685
            -169.671513, 59.943996
        """.trimIndent(), largeArea.toPolyLine())
    }

    @Test
    fun traverseAreaPerfectFitTest() {
        val size = 5.0
        val result = testArea.divideArea(size)
        var sumOfAllareas = 0.0
        for (area in result) sumOfAllareas += area.calculateTotalArea()

        Assert.assertEquals(9, result.size)
        Assert.assertEquals(Area(55.0, 15.0, 50.0, 10.0), result.first())
        Assert.assertEquals(Area(45.0, 5.0, 40.0, 0.0), result.last())
        Assert.assertEquals(225.0, sumOfAllareas, 0.0)
    }

    @Test
    fun traversAreaNoPerfectFitTest() {
        val size = 6.0
        val result = testArea.divideArea(size)
        var sumOfAllareas = 0.0
        for (area in result) sumOfAllareas += area.calculateTotalArea()

        Assert.assertEquals(9, result.size)
        Assert.assertEquals(Area(55.0, 15.0, 49.0, 9.0), result.first())
        Assert.assertEquals(Area(43.0, 3.0, 40.0, 0.0), result.last())
        Assert.assertEquals(225.0, sumOfAllareas, 0.0)
    }

    @Test
    fun traverseAreaMaxSizeTest() {
        val size = 16.0
        val result = testArea.divideArea(size)

        Assert.assertEquals(1, result.size)
        Assert.assertEquals(Area(55.0, 15.0, 40.0, 0.0), result.first())
        Assert.assertEquals(225.0, result.first().calculateTotalArea(), 0.0)
    }

    @Test
    fun traverseAreaOutOfBoundsTest() {
        val size = 16.0
        val result = testArea.divideArea(size)

        Assert.assertEquals(1, result.size)
        Assert.assertEquals(Area(55.0, 15.0, 40.0, 0.0), result.first())
        Assert.assertEquals(225.0, result.first().calculateTotalArea(), 0.0)
    }

    @Test
    fun traverserWestEuropeTest() {
        val size = 0.5
        val result = westEuropeArea.divideArea(size)
        var sumOfAllareas = 0.0
        for (area in result) sumOfAllareas += area.calculateTotalArea()

        Assert.assertEquals(253, result.size)
        Assert.assertEquals(Area(54.378286, 10.719496, 53.878286, 10.219496), result.first())
        Assert.assertEquals(Area(49.378286, -0.28050400000000053, 48.964649, -0.379124), result.last())
        Assert.assertEquals(westEuropeArea.calculateTotalArea(), sumOfAllareas, 1.0)
    }

    @Test
    fun traverseWesEuropeMaxValue() {
        val size = 61.0
        val result = westEuropeArea.divideArea(size)

        Assert.assertEquals(1, result.size)
        Assert.assertEquals(Area(54.378286, 10.719496, 48.964649, -0.379124), result.first())
        Assert.assertEquals(60.0, result.first().calculateTotalArea(), 1.0)
    }

    @Test
    fun traverseLargeAreaTest() {
        val size = 10.0
        val result = largeArea.divideArea(size)

        Assert.assertEquals(629, result.size)
    }
}
```

### Integratie test: Collecting data from the TeqPlay platform
Zoals je kunt lezen in de unit tests hierboven verzamelen we data uit het TeqPlay platform, dit is één van de eerste dingen die gebouwd is voor ons systeem. 
Een script dat een API request maakt naar de het TeqPlay platform en zo schepen binnenhaalt, om dit te testen moet je een intergratie test gebruiken omdat het stuk code afhankelijk is van een derde partij. Als die derde partij dan iets veranderd in de API dan zie je dat meteen terug in het test resultaat.

Zie hieronder de code om een request te maken naar het platform: 

```

fun platformParser(token: String, area: Area, showAged: Boolean = false, includeAgent: Boolean = false ): ResponseEntity<Array<ShipInfoStaticPlatform>>{
    val headers = HttpHeaders()

    //Login into the platform
    headers.add("Authorization", token)

    val url = "${ConfigCreator.getPlatformConfig().host}/ship/details?topLeftLat=${area.TopLeftLat}&topLeftLon=${area.TopLeftLon}&bottomRightLat=${area.BottomRightLat}&bottomRightLon=${area.BottomRightLon}&showAged=$showAged&includeAgent=$includeAgent"
    return RestTemplate().exchange(url,
            HttpMethod.GET,
            HttpEntity<String>(headers),
            Array<ShipInfoStaticPlatform>::class.java)

}
```

Er is getest onder de volgende criteria: 
- De response van het platform moet een statuscode 200(OK)terug geven.
- Het dat in de response body zit moet groter zijn dan 0. 

Als één van deze resultaten afwijkt dan zou je kunnen concluderen dat er iets mis gaat aan de kant van het platform of de verbinding daartussen. Zie hieronder de test: 

```
@Category(IntegrationServiceImpl::class)
internal class PlatformParserTest {

    @Test
    fun checkRequest(){
        val token = login().body.token
        val conf = ConfigCreator.getPlatformAreaConfig()
        val result = platformParser(token, Area(conf.maxTopLeftLat, conf.maxTopLeftLon, conf.minBottomRightLat, conf.minBottomRightLon))

        Assert.assertEquals(HttpStatus.OK, result.statusCode)
        Assert.assertNotEquals(0, result.body.size)
    }
}
```


# Het vervolg 

Vanaf dit moment ben ik 13 weken bezig met mijn stage, we hebben al flink wat geprogrammeerd en een mooi product neergezet. 

<!--truncate-->

Naast de backend ben ik nu ook bezig met de frontend en het design van een mooie user interface. Je merkt dat we in 10 weken tijd een stabiele basis hadden voor het project met een duidelijk doel van wat het systeem moet kunnen. In de komende weken zal ik meer gaan werken naar het gebruik toe, om te kunnen zorgen dat in eerste instantie andere werknemers het systeem kunnen gebruiken. 


## Analyseren
**AN2, AN3)** Bij deze competenties gaat er vooral om de requirements van het systeem in kaart te brengen, wat moet het systeem kunnen en wat moeten de gebruikers kunnen doen met het systeem. Zijn er verschillende gebruikers en hebben al die gebruikers verschillende rechten? Binnen deze competentie laat ik in een use case diagram zien wat de scope is van het project. Het was overigens handiger geweest om dit aan het begin van het project te maken voordat je begint met coderen, maar dit heeft zeker tot nieuwe inzichten geleidt voor het project. Om het project een duidelijk doel te geven en anderen te laten zien hoe ik precies denk over het project. 
![alt](/blog/assets/usecase-shiphappens.png) *Use case*

Wat te zien is in dit diagram zijn de verschillende gebruikers en systeem onderdelen die iets te maken hebben met het systeem en wat er van het systeem verwacht wordt. Een aantal eisen zijn dat het systeem nieuwe informatie moet binnenhalen in een vastgesteld tijd schema. Andere onderdelen zijn dat het systeem alle veranderingen op de database bij moet houden en als een schip handmatig wordt aangepast dat het dan in een aparte collectie wordt opgeslagen. 

Deze use cases worden vervolgens omgezet in kaarten die worden toegevoegd op het Trello bord. 

![alt](/blog/assets/trello-bord-bij-AN2-3.PNG)

## Ontwerpen
**O2)**
Bij [Ontwerpen 1](/blog/2018/10/30/Stage-TeqPlay-eerste-8-weken#ontwerpen) heb ik een eerste opzet van een component diagram gemaakt. Gedurende het project is er meer duidlijkheid gekomen over de structuur van het project en is het diagram ook wat veranderd. In onderstaand diagram zijn alle componenten concreter uitgewerkt en wordt de structuur van het systeem weergegeven.

![alt](/blog/assets/class-diagram-shiphappens.png) *Class Diagram*

In het diagram zijn de belangrijkste onderdelen van de backend geschetst, het systeem bestaat uit vier packages: 
- logic
- models
- controllers
- datasources

In de **logic** staat de kern van het systeem, dit onderdeel is verantwoordelijk voor het verzamelen van informatie en het samenvoegen van die informatie tot één bron, in de **models** staan alle data modellen van hoe de data eruit ziet. De **controllers** zijn verantwoordelijk voor het naar buiten beschikbaar maken van de data en die data wordt uit de de database gehaald door de **datasources**, deze is tevens ook verantwoordelijk voor alle CRUD(Create, Read, Update en Delete) operations op de database. 


## Realiseren
**R1)**
Bij deze competentie zit het daadwerkelijk bouwen van de software bij in, hier volgt de implementatie van de applicatie volgens de eerder gemaakte diagrammen. De applicatie maakt gebruik van het [REST MVC](https://softwareengineering.stackexchange.com/questions/324730/mvc-and-restful-api-service) pattern. De backend bestaat uit de models en de controllers voor het beschikbaar maken van de data. De view(de frontend) staat in een los staande applicatie, dit is de opmaak en visualisatie van de data. In de backend is de systeem logica gescheiden van de rest van de applicatie. De backend is geschreven in Kotlin en voor de REST API wordt gebruik gemaakt van Springboot. 
De frontend is geschreven in Typescript en maakt gebruik van React, dit is tevens de standaard voor frontend applicatie bij TeqPlay. 

Hieronder volgen een aantal code snippets en design implementaties: 

### Backend

Project structuur:

 ![alt](/blog/assets/directory-structure.PNG)


Controller: ![alt](/blog/assets/controller-shiphappens.PNG) 

Datasource: ![alt](/blog/assets/datasource-shiphappens-standaard.PNG)

Datasource method: ![alt](/blog/assets/datasource-insertmany-method.PNG)

Ship model: ![alt](/blog/assets/model-shipinfo.PNG)


### Frontend

De frontend houdt voor in het vervolg een simpel design aan, ons project moet je zien als de Google voor scheepsinformatie. Wij verzamelen heel veel informatie en geven die vrij aan de gebruiker zodra die er om vraagt. We geven dus net als Google geen inkijk in onze database, maar geven alleen de informatie vrij als er om gevraagd wordt. Als je het ontwerp met de implementatie vergelijkt zie je overeenkomsten en verschillen. Een verschil zijn de knoppen om te zoeken die weg gelaten zijn in de implementatie, het was volgens het bedrijf handiger om die knop weg te laten. Zodra de gebruiker klaar is met typen dan wordt er een request naar de server gemaakt en zie je automatisch het zoekresultaat op het scherm. Een ding in het ontwerp dat hetzelfde is gebleven is de afgeronde hoeken, als je kijkt naar veel websites en producten zie je overal afgeronde hoeken en dat wordt door de consument als mooi ervaren. Kijk maar naar websites als Google, Facebook en YouTube, maar ook in producten om ons heen. Zoals telefoons, computers, autos, tafels etc. 

<img width="300px" src="/blog/assets/IMG_20181204_091110.jpg" alt="image"><img width="400px" src="/blog/assets/home-pageshiphappens.PNG" alt="image">

![alt](/blog/assets/dropdown-schets.png)



# Mijn verwachtingen

Ik ben nu een aantal weken bezig met mijn stage bij TeqPlay, ben zelfs al over de helft van de stage periode. Dus dit leek mij een mooi moment om terug te blikken op het begin, mijn verwachtingen die ik had over het bedrijf en hoe deze verwachtingen in de praktijk zijn uitgevallen. 

<!--truncate-->

De eerste weken werd ik al meteen flink aan het werk gezet, er werden een handvol accounts aan gemaakt om te werken binnen het bedrijf en met de systemen van het bedrijf. Zo was de eerste week vooral bedoeld om te spelen met de API van het bedrijf om scheepsinformatie op te halen en te kijken wat er allemaal beschikbaar was. 

## Skills en attitude 
**S1)** Iets wat heel erg in de naam zit van het bedrijf zijn de woorden Technology en Play, het spelen met nieuwe technologieën is waar TeqPlay voor staat. Dat is dus ook wat mij in het begin vrij duidelijk werd, zo was er voldoende tijd en ruimte om een hele dag te besteden aan het volgen van een Kotlin [tutorial](https://kotlinlang.org/docs/tutorials/) of spelen met [mongoDB](https://docs.mongodb.com/). Verder wat ik terug zie in TeqPlay is dat het echt nog een beginnend bedrijf is, de software en applicaties die ze gemaakt hebben zijn nog in volle ontwikkeling en er wordt dus ook elke dag aan nieuwe dingen gewerkt. Er is dus ook ruimte binnen het bedrijf om zelf met nieuwe ideeën te komen. 
Tenslotte iets wat volgens mij iets heel typisch is voor IT bedrijven is het werken met sprints, bij TeqPlay doen ze dus tweewekelijkse sprints. Het is ook gebruikelijk om aan het eind van een sprint of week het werk even neer te leggen en met ze allen de week te bespreken onder het genot van een drankje. 
Iets wat ook heel typisch is aan IT bedrijven is dat er altijd wel een activiteit op de werkvloer om even niet aan het werk te hoeven denken. Bij TeqPlay is dat de voetbal tafel, of hoe zij het noemen [foosball](https://foosball.teqplay.nl/#/home). De standen worden heel officieel bij gehouden op het leaderboard. 


**S2)** Aan het einde van een sprint is er een demo, tijdens deze demo laten we aan het bedrijf en de begeleiders zien wat we gedaan hebben. Dit is ook het moment voor feedback op ons ontwerp en aan ons om hier iets mee te doen. Ook hebben we al een aantal keer een code review gehad, hieruit blijkt dan vaak dat sommige stukken net wat handiger gebouwd kunnen worden. 

- [code review 1](/blog/assets/Code-review-1.pdf)

![code review 2](/blog/assets/code-review-2.PNG)

Wat uit de code review blijkt is dat er onder andere wat spelfouten zitten in de documentatieen, dat er meer comments geplaatst moeten worden en een conf file gemaakt moet worden. Dit zijn allemaal voorbeelden van hoe de code leesbaarder, schaalbaarder en onderhoudtbaarder wordt. Uitendelijk is het ook de bedoeling dat andere programmeurs mijn code moeten kunnen terug lezen.


Ik zit dus nu in de laatste week van het jaar van mijn stage, deze week ben ik voornamelijk bezig met het verbeteren van code in het project, documentatie schrijven en zorgen dat het systeem stabiel kan draaien op de student server van TeqPlay. Ervoor zorgen dat alle code leesbaar is en het project voor mijn gevoel goed afgerond wordt. 

# Laatste stappen

Ik ben de laatste weken in gegaan van mijn stage bij TeqPlay, op dit moment is er een werkend prototype van de masterdatabase neergezet op de student server van het bedrijf. 

<!--truncate-->

Het prototype is beschikbaar via deze [link](http://demo.teqplay.nl/shiphappens/)

![alt](/blog/assets/live-demo-shiphappens.PNG)

## Analyseren

**AN4)** Vanaf dit moment is het goed om terug te blikken op wat er gedaan is en wat er nog gebeuren moet. Hiervoor is een [acceptatietest](https://nl.wikipedia.org/wiki/Acceptatietest)  geschikt om te onderzoeken of het product bruikbaar is en wat er nog veranderd moet worden.

### Acceptatietest: ShipHappens

Het doel van ShipHappens is om data over schepen te verzamelen uit verschillende bronnen en dit te combineren tot één databron. Vervolgens moet deze data beschikbaar gemaakt worden voor eindgebruikers, zodat ze schepen kunnen opzoeken en alle nodige informatie over dat schip kunnen vinden. 

Vragen die je kan stellen om te concluderen of het systeem acceptabel is zijn: 
- Reageert het systeem meteen?
- Is informatie geordend, zodat de gebruiker weet waar die moet zoeken? 
- Als de gebruiker iets aanpast ziet hij dan meteen resultaat? 

Op dit moment draait het systeem dus op de studentserver van TeqPlay en is het beschikbaar voor gebruikers via deze [link](http://demo.teqplay.nl/shiphappens/). Een aantal dingen die het systeem nog niet doet is snel reageren. Dit komt doordat het systeem moet zoeken in een database van meer dan 400.000 schepen, dit gaat op dit moment dus nog erg traag. Een ander probleem tot dit moment is de routes van de URL's. De react-router werkt blijkbaar niet goed samen met een Amazon S3 bucket, dit veroorzaakt dat de detail pagina niet bereikbaar is. Lokaal is deze wel bereikbaar. Op de detail pagina zijn gegevens geordend in categorieën, de volgende categorieën zijn beschikbaar: 
- Identifiers
- Measurements
- Static info
- Categorieën

![alt](/blog/assets/detail-page-shiphappens.PNG)

Achter elke categorie staat een pen tool, waardoor de gebruiker in staat is om de gegevens te bewerken. Op het moment dat de gebruiker iets aanpast wordt het schip toegevoegd aan een aparte collectie met user input data. Vervolgens wordt het schip meteen samengevoegd met de andere data, waardoor de gebruiker meteen resultaat ziet. 

### Conclusie
Wat er dus op dit moment staat is een werkend prototype, van een masterdatabase en een Google-achtige zoekmachine die direct toegang geeft tot de data. Wat het systeem goed doet is het meteen laten zien van resultaat als een schip is aangepast. Dat de gebruiker niet eerst 5 minuten hoeft te wachten. Verbeterpunten voor het systeem op dit moment is zorgen dat elke pagina zowel als in productie als lokaal beschikbaar is. Een ander punt is het verbeteren van de performance, zorgen voor een snellere zoekmethode om in grote datasets een schip te vinden. Een methode daarvoor is het gebruik van indexen in de database, waarbij de schip id's gekoppeld zijn aan een op alfabet gesorteerde lijst. Hiermee kan het systeem sneller het juiste schip vinden. In mongoDB heet dit [compound indexing](https://docs.mongodb.com/manual/core/index-compound/#create-a-compound-index), dit is dus een ding waar ik mij de laatste weken op ga focussen. Voor mij is dit een nieuwe techniek dus zal ik mij hier eerst over moeten gaan inlezen, een klein projectje bouwen als experiment en vervolgens toepassen op het project. Als blijkt dat het probleem hieraan ligt. 


## Adviseren

**AD1)** In het project hebben we gekozen om bepaalde frameworks, tools en technieken te gebruiken om het doel van het project te bereiken. Sommige tools en frameworks hebben we van het bedrijf aangeraden gekregen en andere hebben we zelf voor gekozen om te gebruiken. Als database systeem bijvoorbeeld heeft het bedrijf aangeraden om te kiezen voor [MongoDB](https://www.mongodb.com/). Dit is een noSQL database, dus zonder relaties. Het voordeel is dat je dan niet vast zit aan een standaard database model en makkelijk nieuwe gegevens kunt toevoegen als er nieuwe info wordt ontdekt. Bij een SQL database moet hiervoor eerst alle relaties worden aangepast en een nieuwe migratie worden uitgevoerd op de database tabellen(het opnieuw formateren van de database). 
![alt](/blog/assets/mongoDB-example-1.PNG)

Verder hebben we op aanraden van het bedrijf ook gekozen voor de taal [Kotlin](https://kotlinlang.org/), Java is op dit moment nog de standaard bij het bedrijf. Aangezien ze willen stappen op Kotlin was dat voor ons ook een logische keuze. Zodat de applicatie binnen het bedrijf zou passen, Kotlin is ook een dialect van Java met simpelere syntax.

Een taal waar ik wel zelf voor heb gekozen is [Typescript](https://www.typescriptlang.org/), dit had ik vanuit school ook al geleerd. Het standaard frontend framework by TeqPlay is [React](https://reactjs.org/). Dus dat hadden we ook gebruikt voor de frontend van het project, hierbij ligt dan de keuze of we Javascript of Typescript gaan gebruiken. De keuze voor Typescript was vooral vanwege de schaalbaarheid, de syntax lijkt vrij veel op C# wat ik gewend was vanuit school. Verder zitten er features in als typechecking, interfaces en inheritance. Dit was voor een data applicatie die wij maakte erg handig omdat het datatype van de verschillende bronnen erg belangrijk is. In Javascript krijg je dan eerder een runtime error omdat bepaalde typen niet met elkaar matchen, terwijl in Typescript je dan al een compile error krijgt. Op deze mannier haal je een hoop fouten er dus al uit voordat de applicatie opgestart wordt.



## Skills en attitude

**S3)** Voor deze competentie zie mijn feedback en zelfreflectie formulier ingevult door mij en de bedrijfsbegeleider.

[Feedback formulier](/blog/assets/Feedbackformulier-Steven-Koerts-0904861.pdf)
Het feedbackformulier is gezamenlijk gemaakt door alle studenten van TeqPlay, [Catalina Andreita-Carstoiu](http://www.catalinaandreita.nl/), [Joost Zonneveld](http://jozonneveld.nl/) en [Maurice van Veen](http://teqplay.derdejaarsstage.mauricevanveen.com/)

De conclusie van het feedbackformulier komt er bij mij voornamelijk op neer dat ik mijzelf niet te veel met andere moet vergelijken, dus niet kijken of ik beter of slechter in programmeren ben dan de ander. Het is voorral belangrijk om naar mijn eigen werk te kijken en daar het beste uittehalen. Een erg positief punt is dat ik nieuwe technieken snel op weet te pakken en er ook energie uithaal om nieuwe dingen te leren. Het blijft voormij dan nog wel lastig om vervolgens die nieuwe techniek toe te passen in de praktijk en ook de nieuwe informatie over te brengen op collaga's. Verder is het ook belangrijk om niet één oplossing te zoeken voor een probleem en ook met alternatieven te komen, als het gaat om software development is er tevens nooit één oplossing.


# Performance Test

Zoals in deze [acceptatietest](/blog/2019/01/08/Stage-Teqplay-De-laatste-stappen#acceptatietest-shiphappens) te lezen is bleek dat de zoekfunctie van de applicatie erg traag was. Om uit te zoeken hoe dit kwam heb ik een performancetest gedaan. 

<!--truncate-->

## Realiseren R2
## Testplan performancetesttest zoekfunctie ShipHappens

Uit het gebruik van het systeem is gebleken dat de zoekfunctie
enorm traag wordt als er meer schepen in de database zitten. Bij 
400.000 schepen moet je zo een 8 seconden wachten totdat je resultaat
ziet. Vandaar dit testplan om uit te zoeken waar dit aan ligt. 
Verder blijkt het dat als de collectie met schepen groter wordt de
response tijd ook groter wordt.

**Dus de hoofdvraag van deze test is: Wat is het dat response tijd van de zoekfunctie van de applicatie traag maakt?**


### Mogelijke oorzaken
- Trage mongoDB queries
- Zware operaties in de backend die aangeroepen wanneer er een zoekopdracht wordt gedaan

### Onderzoeksmethoden
1. Om er achter te komen of de mongo query te zwaar is en teveel rekenkracht inneemt kan gekeken worden naar de tijd als je de query handmatig invoert. 
   Aangezien de tijd elke keer anders is moet de query een aantal keer achter elkaar uitgevoerd worden voor een goed resultaat. Dit heeft te maken met dat
   de tijd hoelang een query erover doet ook afhankelijk is van de processor snelheid. Als dit het probleem is dan zal [compound indexing](https://docs.mongodb.com/manual/core/index-compound/) een goede oplossing zijn. 
   ![alt](/blog/assets/mongoDB-performance-test.PNG)

De resultaten kun je uitzetten in de volgende tabel: 
![alt](/blog/assets/result-mongo-test.PNG)

2. Om de tijd van de operaties in de backend te meten kan een stopwatchmethode worden gebruikt die in Kotlin zit ingebouwd. De response tijd hangt dus af van de grote van de collectie. Dus in een tabel kan de collectie grote worden uitgezet tegen de tijd van een bepaalde operatie in het systeem. Eerst zullen de handelingen in kaart gebracht moeten worden van het maken van de request tot aan het terug sturen van het resultaat. 
   ![alt](/blog/assets/api-call-performance-test.PNG)
   ![alt](/blog/assets/api-call-performance-test-2.PNG)

De responsetijd wordt op het scherm geprint:
![alt](/blog/assets/make-search-query-response-time.PNG)
Vervolgens kan per handelijk de tijd gemeten worden en dan de totale response tijd worden berekend.
![alt](/blog/assets/backend-test-table-sample.PNG)



## Testrapport

Hieronder zijn de resultaten uitgewerkt in een testrapport. 


### Resultaten
![alt](/blog/assets/test-results-performance-test.PNG)
Zoals in de tabel te zien is ligt de traagheid niet aan de mongoDB query, de database geeft in 0,008 seconden een resultaat terug bij het doorzoeken 130.000 schepen. 
![alt](/blog/assets/MongoDB-collection-size.PNG)
Er is meerdere keren getest omdat de tijd ook afhankelijk is van de hardware van de computer, het kan zijn dat de pc op het moment van de test iets anders op de achtergrond aan het doen was waardoor de responsetijd trager wordt. Dus vandaar wordt het gemiddelde genomen. 

Verder is er te zien dat het ophalen van data gemiddeld 1,5 seconden kost, met uitschieters naar de 5 seconden. De responsetijd is hier afhankelijk van de collectie grote, hoe meer schepen in de database hoelanger de responsetijd. Dit komt dus door de `searchShip` methode, in die methoden zitten wat operaties die de request vertragen. Eén van de dingen die veranderd kan worden is het verplaatsen van zware methoden naar de mongoDB, dan is het systeem daar niet meer verantwoordelijk voor. Eén van de zware operaties was het kleiner maken van de collectie, er worden maximaal 20 schepen naar de frontend gestuurd. Omdat een webbrowser kan crashen als er teveel data wordt ingeladen en de gebruiker heeft er ook niet zo veel aan als hij/zij 20.000 schepen op het scherm te zien krijgt. 


## Conclusie

Wat dus blijkt uit deze test is dat het probleem dus niet bij mongoDB ligt maar bij het systeem zelf. MongoDB is dus vele malen sneller in het opzoeken en kleiner maken van datasets. De oplossing voor compound indexing zal het niet heel veel sneller maken, dit is overigens wel handig als de database groter wordt dan een miljoen schepen. Dat is nog niet het geval, maar met oog op de toekomst zal het zeker handig zijn om dit te implementeren. Het gebruik indexen in de database maakt het opzoeken van gegevens een heel stuk sneller, dit blijkt ook uit de officiële documentatie. 

De oplossing om de limiet operatie te verplaatsen naar de mongo database en niet meer in de backend te laten uitvoeren maakt een groot verschil, de responsetijd is nu stabiel rond de 10 milliseconden. 
![alt](/blog/assets/perfamnce-improvements.PNG)


# Einde stage

Dit is de laatste blog post van mijn portfolio. Deze blog heb ik gedurende mijn stage bijgehouden, in deze laatste post zal ik kort terugblikken op wat ik heb gedaan en ziet u nog één keer alle uitgewerkte competenties en leerdoelen achterelkaar.  

<!--truncate-->

Tijdens mijn stage heb om de x aantal weken een blog bijgehouden, waar mijn voortgangen en werkzaamheden staan beschreven. Met als belangrijkste, wat ik geleerd heb. Met welke kennis ben ik mijn stage ingegaan en met welke kennis heb ik mijn stage afgesloten? 

Al deze competenties en leerdoelen heb ik behaald door het werken aan het [ShipHappens project](/docs/ShipHappens).

## Documenten
Voor mijn stage heb ik de volgende documenten gemaakt en bijgehouden: 
- [Stageplan deel 1](/blog/assets/Stageplan-1-Teqplay-Steven-Koerts-0904861.pdf)
- [Stageplan deel 2 v1](/blog/assets/Stageplan-2-Teqplay-Steven-Koerts-0904861.pdf)
- [Stageplan deel 2 v2](/blog/assets/Stageplan-3-Teqplay-Steven-Koerts-0904861.pdf)
- [Sprint logboek](/blog/assets/Sprint-logboek.pdf)
- [Feedback formulier](/blog/assets/Feedbackformulier-Steven-Koerts-0904861.pdf)
- [Code review](/blog/assets/Code-review-1.pdf)

Het stageplan heb ik voorafgaand gemaakt aan mijn stage, hierin staan mijn verwachtingen informatie over TeqPlay, de vantevoren gestelde leerdoelen, uitleg bij de competenties(o.a. hoe ik die ga aantonen). Verder heb ik een sprint logboek bijgehouden waar ik per twee weken bij heb gehouden wat ik in een bepaalde sprint gedaan heb, verder is er ook nog een code review van de bedrijfsbegeleider en als laatste is er het feedback formulier van de bedrijfsbegeleider. 

## Leerdoelen
Aan het begin van mijn stage heb ik twee leerdoelen gesteld aan mezelf. Wat ik graag nog wou leren tijdens mijn stage. 

### Leerdoel 1

Leerdoel 1 heb ik gedurende het project wat bijgesteld, het project ShipHappens ging voornamelijk over big data. Eerst wou ik meer te weten komen over machinelearning, maar het bleek in het project al ingewikkeld genoeg om een goede kwaliteit dataset op te bouwen. Een onderwerp waar ik zelf in de toekomst ook nog meer over wil leren. De vraag die ik mezelf bij het project heb gesteld is: "Waar haalt TeqPlay al zijn data vandaan en hoe weet je of een bron betrouwbaar is?". Het probleem dat ons project beschrijft is dat het bedrijf informatie uit veel verschillende bronnen haalt en het bedrijf zou graag één grote databron willen hebben waar alle verschillende bronnen samengevoegd zijn. Dus kortom wat ik hier wou leren is hoe je grote hoeveelheid data analyseert en de context van de databron weet te achterhalen, welke data is relevant en wat gebruiken we niet. 

Dit leerdoel heb ik behaald door het onderzoeken van verschillende bronnen, om eerst de bron te analyseren en vervolgens aan de database toe te voegen. 
Zo ben ik in de eerste weken aan de slag gegaan met het kijken naar hoe de dataset van TeqPlay eruit zag, wat ze in hun eigen systeem hadden staan. Hierbij heb ik dan ook een diagram gemaakt om te laten zien hoe een schip eruit ziet. 

Deze afbeelding staat ook bij [analyseren 1](/blog/2018/10/30/Stage-TeqPlay-eerste-8-weken#analyseren)
![alt](/blog/assets/Data-with-there-identifiers.png)

Aan de hand van dit diagram kan dan een data model worden geïmplementeerd in het systeem: 

```
@JsonInclude(JsonInclude.Include.NON_NULL)
class ShipInfoStaticPlatform(
        val teqplayId: String? = null,
        mmsi: String? = null,
        val _id: String? = null,
        eni: String? = null,
        imoNumber: String? = null,
        positionOfTransponder: PositionOfTransponder? = PositionOfTransponder(),
        hazardCode: Int? = null,
        //shipWidth and shipLength are in meters
        width: Double? = null,
        length: Double? = null,
        positionSensorType: String? = null ,
        aisVersion: String?  = null,
        callSign: String?  = null,
        name: String? = null,
        shipType: String? = null,
        combinationType:String? = null,
        category: String? = null,
        role: String? = null,
        val static_source: Sources = Sources.TEQPLAY_PLATFORM,
        val date: String = Date().toString()
)
```

Vervolgens zijn dit de stappen die nodig zijn voor het toevoegen van een nieuwe bron: 
1. Het analyseren van de informatie die de bron bevat
2. Bedenken wat de herkomst is van alle informatie, door mensen of computers geproduceerd? 
3. Het opstellen van een diagram met alle bruikbare gegevens
4. Het diagram implementeren in het systeem
5. Een prioritering bedenken hoe de data gecombineerd gaat worden met andere bronnen, hierbij is het belangrijk om te weten of er dubbele data is

Het belangrijkste wat ik hiervan heb geleerd is het belang van een goede voorbereiding en een goed ontwerp. Om eerst bij een casus of probleemstelling stil te staan en erover nagedacht te hebben voordat je aan de slag gaat met het daadwerkelijk bouwen. Voor projecten die ik in de toekomst ga doen zou ik langer willen stil staan bij de ontwerpfase. Hier geld dan overigens een goed begin is het halve werk.

### Leerdoel 2

Leerdoel 2 ging over software deployment, hoe zet je een systeem online en dat het ook nog onderhoudtbaar is. Ook gaat het er hierbij om netjes te programmeren, zorg dat er voldoende comments in de code staan. Gemaakte diagrammen, API documentatie, build scripts en README files. Dit alles heeft te maken met het maken van onderhoudbare software en dus ook met software deployment.

Dit leerdoel heb ik behaald door zelf uit te zoeken hoe je een systeem op een server zet en daarbij ook de nodige stappen te noteren. Uiteindelijk stelt het online zetten van een software systeem niet zo veel voor, het is een kwestie van een serie commando's op de juiste volgorde achter elkaar uittevoeren op een server. Ik ben hierdoor wel anders naar software systemen gaan kijken, hierdoor heb ik nu ingezien hoe belangrijk het is om goed onderscheidt te maken tussen een development- en een productieomgeving. Dit vooral met het oog op database wachtwoorden die verschillen tussen de omgevingen.
Hieronder zijn de stappen die nodig zijn voor de deployment van het project, in eerste instantie had ik niet opgeschreven waardoor ik binnen de kortste keren vergeten was hoe het ook alweer moest. Hiervan heb ik dus geleerd dat het belangrijk is om dit soort handelingen meteen op te schrijven. Dus ook de documentatie goed bij te houden. 

Zie hieronder de stappen die je moet maken om de software online te zetten of te updaten:
![alt](/blog/assets/readme-shiphappens-deployment-steps.PNG)

Een ander belangrijk onderdeel wat bij het leerdoel hoort is het bijhouden van documentatie, het plaatsen van voldoende comments in de code, API documentatie beschikbaar maken en zorgen voor diagrammen van de systeem structuur. Dit alles heeft te maken met de onderhoudbaarheid van het systeem en of andere developers er aan verder kunnen werken. Een groot diagram van het systeem is [hier](/docs/ShipHappens#werking) te vinden, verder staat hieronder de API documentatie van het project. Hier kan een gebruiker of developer vinden welke interacties hij/zij kan hebben met het systeem, o.a. hoe je alle informatie van een schip moet opvragen.

![alt](/blog/assets/Swagger-api-documentation.PNG)

Kortom, het belangrijkste wat ik hierbij geleerd heb is dat documentatie iets is wat niet pas aan het eind van een project komt. Als je het gedurende het project bijhoudt scheelt dat een hoop werk voor later, plus dat je dan soms vergeet hoe iets precies werkt wat je gebouwd hebt. Ook heb ik ingezien dat documentatie niet iets is dat één keer wordt geschreven, maar constant veranderd. Door o.a. gebruik te maken van automatische documentatie tools zoals [Springfox](https://springfox.github.io/springfox/docs/current/), zorg je ervoor dat als er veranderingen in de code plaatsvinden dat de documentatie ook meteen wordt geüpdatet. Want ook in de praktijk zie je vaak dat software veranderd en de documentatie niet wordt bijgewerkt, of wordt uitgesteld naar een later moment.

### Reflectie

In dit [document](/blog/assets/Reflectie-leerdoelen-Steven-Koerts-0904861.pdf) staat de reflectie op mijn leerdoelen, door mij en mijn bedrijfsbegeleider. 

Ik ben het eens met de reflectie van de bedrijfsbegeleider, aan het begin van mijn stage had ik als leerdoel om meer te leren over machinelearning. Dat leerdoel heb ik later bijgesteld want het bleek al lastig genoeg om een goede kwaliteit dataset te creëren. Dit project zou ik in het vervolg anders aanpakken door langer bij de analyse stap stil te blijven staan en eerst goed erover na te denken wat die data nu precies betekend en hoe relevant het is.

Verder weet ik nu dat deployment meer ingoudt dan software op een server neerzetten, ik heb het nut ervan ingezien om het systeem eerst goed te testen voordat ik aan iets nieuws begin of een live deployment doe. Daarom is het ook belangrijk om de documentatie goed bij te houden en meteen een unit test bij een nieuwe functie te schrijven. 


## Persoonlijke groei

Dus mijn leerdoelen hadden vooral te maken met het verzamelen en valideren van data en het uiteindelijk beschikbaar maken van de data door middel van een live deployment. Mijn leerdoelen hebben zeker invloed gehad op mijn interesse ontwikkeling binnen informatica. Ik weet nu aanzienlijk meer over software deployment dan voor mijn stage, ook omdat ik hier vanuit de opleiding nog niks meegedaan had. Deployment was voor mij nog een blank gebied. Nu heb ik een beter idee wat er allemaal bij komt kijken als je een systeem op een server wilt zetten en beschikbaar wilt maken voor anderen. Het geeft mij overigens een erg goed gevoel als ik een live deployment heb gedaan en vervolgens een [link](http://demo.teqplay.nl/shiphappens/) kan delen met anderen. Om te laten zien wat ik gemaakt heb. 

Verder op het gebied van het verzamelen van data. Hier neem ik vooral mee wat grote datasets doen met je applicatie, dat je dan ook over de performance moet gaan nadenken. Anders wordt de applicatie enorm traag. Wat ik volgende keer anders zou doen is eerder gaan nadenken over de hoeveelheid data die het systeem per keer inlaadt en niet honderdduizenden records tegelijk. Tenslotte zou ik het leuk vinden om richting de data verzamel kant te gaan later. Dus niet bezig zijn met wat er met de data gebeurd, maar waar het vandaan komt. Hoe betrouwbaar de bronnen zijn, hoe combineer je verschillende bronnen, hoe ga je om met veranderingen en hoe maak je de data beschikbaar voor anderen. Wat ik in het vervolg dus anders zou doen is langer stil staan bij het analyseren van de databronnen, voordat ik aan de slag ga met programmeren. 

Als laatste ga ik in op de belangrijkste feedback die ik heb gekregen binnen het bedrijf, wat ik heb gemerkt is dat ik het leuk vind om met nieuwe techniek bezig te zijn en ermee te experimenteren. Vaak zorgt dit dan ook dat ik in een tunnelvissie beland dat dit de techniek is waarmee ik het project ga doen. Een belangrijke feedback is om ook naar andere oplossingen te kijken en dus met twee, drie of meer oplossingen te komen voor een probleem. Er is overigens nooit één oplosing voor een probleem. Verder heb ik gezien hoe belangrijk het is om al je nieuwe bevindingen die je doet door te geven aan andere collega's en teamgenoten. Dit om te verkomen dat er dubbel werk wordt verricht en de ander ook snapt waar jij mee bezig was. Tenslotte ben ik er zeker op vooruit gegaan wat programmeer niveau betreft, ik kijk nu heel anders aan hoe je een webapplicatie kunt opstellen met React. Ook het bouwen van een REST-full API service was nieuw voor mij en is zeker iets wat ik in toekomstige projecten ga toepassen. Mijn stage was ook een mooie uitdaging omdat ik vooral met de programmeertaal Kotlin hebt gewerkt, een dialect op Java. Daarvoor had ik nog nooit iets gedaan met Java of Kotlin. 

Het belangrijkste wat ik uit mijn stage haal is dat er dus niet een vaste formule is om aan een project te werken, iedereen werkt op zijn eigen manier, met eigen voorkeuren voor talen, tools en frameworks. Zo ontwikkel je gedurende een stage/werk periode een bepaalde manier van werken die bij jezelf past en maakt het niet uit in welke taal je iets programmeert of hoe je ergens aan werkt. Het gaat erom dat je samen aan een project werkt die voor iedereen werkt en soms moet je daarvoor je eigen mening en voorkeur bijstellen. Een manier die voor mij prettig werkt is om zelf eerst informatie op te zoeken over bepaalde technieken en vervolgens op vaste momenten te laten zien wat ik heb gevonden en wat je ermee kan. Dit is niet de manier van werken die ik voor elke opdracht zou toepassen, dit is iets dat met meer ervaring waarschijnlijk makkelijker zou worden. Om in de toekomst meer kennis te hebben hoe je een project kan opzetten.


## Competenties
Aan de onderstaande competenties heb ik gedurende mijn stage gewerkt en in een blog de voortgang bijgehouden. Hieronder staat nog één keer kort wat ik voor elke competenties gedaan heb en een verwijzing naar het blog artikel van de volledige uitwerking.

### Beheren 
**B1)** Bij beheren ging het om het kunnen werken volgens een vantevoren goedgekeurde planning. Dit heb ik in de eerste weken laten zien, door actief mee te denken aan nieuwe requirements op het Trello bord en proberen alle kaarten af te handelen in een sprint. Wat voor mij hier een verbeterpunt is om meteen bij te houden wat ik gedaan heb nadat ik iets heb afgehandeld. Als je dit later nog moet op halen dan weet je vaak niet meer wat je precies gedaan had. 

[Beheren](/blog/2018/10/30/Stage-TeqPlay-eerste-8-weken#beheren)

### Analyseren 
**AN1)** Dit gaat over het analyseren van de probleemstelling, in ons geval het bouwen van één databron van scheepsinformatie. De eerste stappen die ik hier heb gezet is het ontdekken van welke informatie er in het TeqPlay platform zit, welke informatie is over een schip bekend en wat is voor het systeem relevant om op te slaan. Wat ik hier goed heb gedaan is eerst een diagram maken van alle gegevens die het platform bevat, in de toekomst zou ik langer bij deze stap stil willen staan voordat ik begin met coderen. 

[Analyseren 1](/blog/2018/10/30/Stage-TeqPlay-eerste-8-weken#analyseren)

**AN2, 3)** Hier ging het vooral om om de requirements van het systeem in kaart te brengen ik heb hiervoor een use case diagram gemaakt, dit is een mooie manier om de het doel van het systeem in kaart te brengen. In eerste instantie had ik dit niet gedaan, maar vervolgens werd het doel van het systeem wel duidelijker toen ik dit gemaakt had. In het vervolg zal ik dit soort schetsen en diagrammen eerder willen maken.

[Analyseren 2 + 3](/blog/2018/12/03/Stage-TeqPlay-Het-vervolg#analyseren)


**AN4)** Deze competentie gaat over het terugblikken en valideren van de requirements, doet het systeem wat het moet doen en wat moet er verbeterd worden. Dit is uitgebreid terug te lezen in de acceptatietest bij [analyseren 4](/blog/2019/01/08/Stage-Teqplay-De-laatste-stappen#analyseren)


### Adviseren
**AD1)** Dit gaat over welke keuzes in technieken en frameworks ik heb gemaakt voor het project. Onder de volgende link kunt u lezen welke stappen ik heb gezet in de gemaakte keuzes en welke technieken ik mij zelf heb laten aanraden. 

[Adviseren 1](/blog/2019/01/08/Stage-Teqplay-De-laatste-stappen#adviseren)


### Ontwerpen
**O1)** Bij deze competentie gaat het om het schetsen van hoe de applicatie eruit komt te zien. Hierbij heb ik de eerste diagrammen gemaakt om de interne structuur van het systeem beter inzichtelijk te maken. Het belangrijkste wat ik hiervan heb geleerd is dat ontwerpen gedurende het bouw proces veranderen en dat het iets is wat je om de zoveeltijd moet bijwerken. 

[Ontwerpen 1](/blog/2018/10/30/Stage-TeqPlay-eerste-8-weken#ontwerpen)

**O2)** Deze competentie gaat over het valideren van mijn ontwerp dat ik de eerste keer heb gemaakt, er is een hoop veranderd in het systeem dus is het ontwerp ook aangepast. De laatste versie van het ontwerp staat [hier](/docs/ShipHappens#werking)

[Ontwerpen 2](/blog/2018/12/03/Stage-TeqPlay-Het-vervolg#ontwerpen)

### Realiseren
**R1)** Deze competentie gaat over het daadwerkelijk bouwen van de software, het eindresultaat van het project staat op mijn [project pagina.](/docs/ShipHappens). Dit is wat er na 5 maanden gerealiseerd is, voor de tussen stappen in het project zie de blog posts. In het voorbeeld is een concreet systeem onderdeel wat uitgewerkt is.

[Realiseren 1](/blog/2018/12/03/Stage-TeqPlay-Het-vervolg#realiseren)

**R2)** Deze competentie gaat over het testen van het systeem. Voor dit project zijn een hoop unit tests geschreven, de unit test in het voorbeeld hieronder gaat over het testen van een algoritme om een gebied op een kaart op te delen in kleinere gebieden. Om de hoeveelheid data die binnengehaald wordt te beperken. De belangrijkste essentie van unit testen is het vergelijken van de verwachte output met de werkelijke output. Ook is het bevorderlijk voor de leesbaarheid van de code. Als een andere developer iets veranderd dan faalt de unit test. Wat ik voornamelijk heb geleerd is dat het belangrijk is om meteen een unit test te schrijven voor een bepaald systeem onderdeel. Testen is niet iets wat aan het eind van het proces komt, maar echt een onderdeel is van het proces. 

Verder heb ook nog een [performancetest](/blog/2019/01/10/Stage-TeqPlay-Performance-test) gedaan, onder andere om de responsetijd van de zoekfunctie te testen. Het bleek dat bij grote database collecties het systeem er ruim 8 seconden over deed om een resultaat terug te geven, in de test staat mijn aanpak beschreven en een aantal mogelijke oplossingen en oorzaken.

[Realiseren 2](/blog/2018/10/30/Stage-TeqPlay-eerste-8-weken#realiseren)


### Skills & Attitude
**S1, 2)** Deze competenties gaan over mijn verwachtingen binnen het bedrijf en of die verwachtingen kloppen met de praktijk. Hier heb ik na 4 maanden op terug geblikt en staat beschreven in onderstaand blogartikel.  

[Skills & Attitude 1 + 2](/blog/2018/12/17/Stage-TeqPlay-Mijn-verwachtingen)

**S3)** Deze competentie gaat over hoe ik heb gefunctioneerd binnen het bedrijf en hoe ik mijzelf opstel binnen het bedrijf. Dit staat onderandere in bovenstaand feedbackformulier en beschreven in onderstaand blogartikel.

[Skills & Attitude 3](/blog/2019/01/08/Stage-Teqplay-De-laatste-stappen#skills-en-attitude)



